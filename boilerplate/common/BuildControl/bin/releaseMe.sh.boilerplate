#!/bin/bash

#
# Cleanroom Project release generator script
#
# by emaloney, 7 June 2015
#

set -o pipefail		# to ensure xcodebuild pipeline errors are propagated correctly

SCRIPT_NAME=$$(basename "$$0")
SCRIPT_DIR=$$(cd "$$PWD" ; cd `dirname "$$0"` ; echo "$$PWD")

showHelp()
{
	echo "$$SCRIPT_NAME"
	echo
	printf "^q(\t)Generates a new release of the project contained in this git^q(\n)"
	printf "^q(\t)repository.^q(\n)"
	echo
	echo "Usage:"
	echo
	printf "^q(\t)$$SCRIPT_NAME <release-type>^q(\n)"
	echo
	echo "Where:"
	echo
	printf "^q(\t)<release-type> is 'major', 'minor' or 'patch', depending on which^q(\n)"
	printf "^q(\t\t)portion of the version number should be incremented for this^q(\n)"
	printf "^q(\t\t)release.^q(\n)"
	echo
	printf "^q(\t)This script also accepts these optional command-line arguments:^q(\n)"
	echo
	printf "^q(\t\t)--set-version <version>^q(\n)"
	printf "^q(\t\t\t)Make <version> the version number being released^q(\n)"
	echo
	printf "^q(\t\t)--auto^q(\n)"
	printf "^q(\t\t\t)Run automatically without awaiting user confirmation^q(\n)"
	echo
	printf "^q(\t\t)--tag^q(\n)"
	printf "^q(\t\t\t)Tags the repo with the version number upon success^q(\n)"
	echo
	printf "^q(\t\t)--push^q(\n)"
	printf "^q(\t\t\t)Push all changes upon success^q(\n)"
	echo
	printf "^q(\t\t)--no-commit^q(\n)"
	printf "^q(\t\t\t)Skips committing any changes; implies --no-tag^q(\n)"
	echo
	printf "^q(\t\t)--no-tag^q(\n)"
	printf "^q(\t\t\t)Overrides --tag if specified; --no-tag is the default^q(\n)"
	echo
	printf "^q(\t\t)--stash-dirty-files^q(\n)"
	printf "^q(\t\t\t)Stashes dirty files before attempting to release^q(\n)"
	echo
	printf "^q(\t\t)--commit-dirty-files^q(\n)"
	printf "^q(\t\t\t)Commits dirty files before attempting to release^q(\n)"
	echo
	printf "^q(\t\t)--ignore-dirty-files^q(\n)"
	printf "^q(\t\t\t)Ignores dirty files; implies --no-commit --no-tag^q(\n)"
	echo
	printf "^q(\t\t)--skip-docs^q(\n)"
	printf "^q(\t\t\t)Skips generating the documentation^q(\n)"
	echo
	printf "^q(\t\t)--skip-tests^q(\n)"
	printf "^q(\t\t\t)Skips running the unit tests :-(^q(\n)"
	echo
	printf "^q(\t\t)--dry-run^q(\n)"
	printf "^q(\t\t\t)Show commands to be executed instead of executing them^q(\n)"
	echo
	printf "^q(\t)Further detail about these options can be found below.^q(\n)"
	echo
	echo "How it works"
	echo
	printf "^q(\t)By default, the script inspects the appropriate property list file(s)^q(\n)"
	printf "^q(\t)to determine the current version of the project. The script then^q(\n)"
	printf "^q(\t)increments the version number according to the release type^q(\n)"
	printf "^q(\t)specified:^q(\n)"
	echo
	printf "^q(\t)major — When the major release type is specified, the major version^q(\n)"
	printf "^q(\t\t)component is incremented, and both the minor and patch^q(\n)"
	printf "^q(\t\t)components are reset to zero. 2.1.3 becomes 3.0.0.^q(\n)"
	echo
	printf "^q(\t)minor — When the minor release type is specified, the major version^q(\n)"
	printf "^q(\t\t)component is not changed, while the minor component is^q(\n)"
	printf "^q(\t\t)incremented and patch component is reset to zero.^q(\n)"
	printf "^q(\t\t)2.1.3 becomes 2.2.0.^q(\n)"
	echo
	printf "^q(\t)patch — When the patch release type is specified, the major and minor^q(\n)"
	printf "^q(\t\t)version components remain unchanged, while the patch component^q(\n)"
	printf "^q(\t\t)is incremented. 2.1.3 becomes 2.1.4.^q(\n)"
	echo
	printf "^q(\t)The script then updates all necessary references to the version^q(\n)"	
	printf "^q(\t)elsewhere in the project.^q(\n)"
	echo
	printf "^q(\t)Then, the API documentation is rebuilt, and the repository is tagged^q(\n)"
	printf "^q(\t)with the appropriate version number for the release.^q(\n)"
	echo
	printf "^q(\t)Finally, if the --push argument was supplied, the entire release is^q(\n)"	
	printf "^q(\t)pushed to the repo's origin remote.^q(\n)"	
	echo
	echo "Specifying the version explicitly"
	echo
	printf "^q(\t)The --set-version argument can be supplied along with a version number^q(\n)"
	printf "^q(\t)if you wish to specify the exact version number to use.^q(\n)"
	echo
	printf "^q(\t)The version number is expected to contain exactly three integer^q(\n)"
	printf "^q(\t)components separated by periods; trailing zeros are used if^q(\n)"
	printf "^q(\t)necessary.^q(\n)"
	echo
	printf "^q(\t)If you wanted to set a release version of 4.2.1, for example, you^q(\n)"
	printf "^q(\t)could call the script as follows:^q(\n)"
	echo
	printf "^q(\t\t)$$SCRIPT_NAME --set-version 4.2.1^q(\n)"
	echo
	printf "^q(\t)NOTE: When the --set-version argument is supplied, the release-type^q(\n)"
	printf "^q(\t)      argument does not need to be specified (and it will be ignored^q(\n)"
	printf "^q(\t)      if it is).^q(\n)"
	echo
	echo "User Confirmation"
	echo
	printf "^q(\t)By default, this script requires user confirmation before making^q(\n)"
	printf "^q(\t)any changes.^q(\n)"
	echo
	printf "^q(\t)To allow this script to be invoked by other scripts, an automated^q(\n)"
	printf "^q(\t)mode is also supported.^q(\n)"
	echo
	printf "^q(\t)When this script is run in automated mode, the user will not be^q(\n)"
	printf "^q(\t)asked to confirm any actions; all actions are performed immediately.^q(\n)"
	echo
	printf "^q(\t)To enable automated mode, supply the --auto argument.^q(\n)"
	echo
	echo "Releasing with uncommitted changes"
	echo
	printf "^q(\t)Normally, this script will refuse to continue if the repository^q(\n)"
	printf "^q(\t)is dirty; that is, if there are any modified files that haven't^q(\n)"
	printf "^q(\t)yet been committed.^q(\n)"
	echo
	printf "^q(\t)However, you can force a release to be issued from a dirty repo^q(\n)"
	printf "^q(\t)using either the --stash-dirty-files or the --commit-dirty-files^q(\n)"
	printf "^q(\t)argument.^q(\n)"
	echo
	printf "^q(\t)The --stash-dirty-files option causes a git stash operation to^q(\n)"
	printf "^q(\t)occur at the start of the release process, and a stash pop at the^q(\n)"
	printf "^q(\t)end. This safely moves the dirty files out of the way when the^q(\n)"
	printf "^q(\t)script it doing its thing, and restores them when it is done.^q(\n)"
	echo	
	printf "^q(\t)The --commit-dirty-files option causes the dirty files to be^q(\n)"
	printf "^q(\t)committed along with the other changes that occur during the^q(\n)"
	printf "^q(\t)release process.^q(\n)"
	echo	
	printf "^q(\t)In addition, an --ignore-dirty-files option is available, which^q(\n)"
	printf "^q(\t)lets you go through the entire release process, but stops short^q(\n)"
	printf "^q(\t)of committing and tagging. This allows you to run through the^q(\n)"
	printf "^q(\t)entire release process without committing you to committing.^q(\n)"
	echo
	printf "^q(\t)Note that these options are mutually exclusive and may not be^q(\n)"
	printf "^q(\t)used with each other.^q(\n)"
	echo
	echo "Dry run mode"
	echo
	printf "^q(\t)Using the --dry-run argument prevents the release from occurring^q(\n)"
	printf "^q(\t)and instead shows what would occur if the release were to be^q(\n)"
	printf "^q(\t)executed using the supplied command-line arguments.^q(\n)"
	echo
	echo "Help"
	echo
	printf "^q(\t)This documentation is displayed when supplying the --help (or^q(\n)"
	printf "^q(\t)-h or -?) argument.^q(\n)"
	echo
	printf "^q(\t)Note that when this script displays help documentation, all other^q(\n)"
	printf "^q(\t)command line arguments are ignored and no other actions are performed.^q(\n)"
	echo
}

printError()
{
	echo "error: $$1"
	echo
	if [[ ! -z $$2 ]]; then
		printf "  $$2^q(\n\n)"
	fi
}

exitWithError()
{
	printError "$$1" "$$2"
	exit 1
}

exitWithErrorSuggestHelp()
{
	printError "$$1" "$$2"
	printf "  To display help, run:^q(\n\n)^q(\t)$$0 --help^q(\n)"
	exit 1
}

validateVersion()
{
	if [[ ! ($$1 =~ ^[0-9]+\.[0-9]+\.[0-9]+$$) ]]; then
		exitWithErrorSuggestHelp "Expected $$2 to contain three period-separated numeric components (eg., 3.6.1, 4.0.0, etc.); got $$1 instead"
	fi
}

updateStatus()
{
	if [[ ! $$QUIET ]]; then
		echo 
		echo "$$1"
		echo
	fi
}

confirmationPrompt()
{
	if [[ ! $$QUIET || ! $$AUTOMATED_MODE ]]; then
		echo
		echo $$1
	fi
	if [[ -z $$AUTOMATED_MODE ]]; then
		echo
		read -p "Are you sure you want to do this? " -n 1 -r
		echo
		if [[ ! $$REPLY =~ ^[Yy]$$ ]]; then
			exit -1
		fi
	fi
}

executeCommand()
{
	if [[ $$DRY_RUN_MODE ]]; then
		if [[ ! $$DID_DRY_RUN_MSG ]]; then
			printf "^q(\t)!!! DRY RUN MODE - Will only show commands, not execute them !!!^q(\n)"
			echo
			DID_DRY_RUN_MSG=1
		fi
		echo "> executing: "
		echo
		echo "	set -o pipefail && $$1"
	else
		unset _CMD
		if [[ $$QUIET ]]; then
			_CMD="set -o pipefail && $$1 > /dev/null"
		else
			_CMD="set -o pipefail && $$1"
		fi
		eval $$_CMD
		if [[ $$? != 0 ]]; then
			exitWithError "Command failed: $$_CMD"
		fi
	fi
}

cleanupDirtyStash()
{
	updateStatus "Restoring previously-stashed modified files"
	executeCommand "git stash pop"
}

#
# make sure we're in a git repo
#
cd "$$SCRIPT_DIR/../../."
git status 2&> /dev/null
if [[ $$? != 0 ]]; then
	exitWithErrorSuggestHelp "You must invoke this script from within a git repo"
fi

#
# parse the command-line arguments
#
AMEND_ARGS=""
BRANCH=master
STASH_DIRTY_FILES=0
COMMIT_DIRTY_FILES=0
IGNORE_DIRTY_FILES=0
while [[ $$1 ]]; do
	case $$1 in
	--set-version)
		shift
		if [[ -z $$1 ]]; then
			exitWithErrorSuggestHelp "The $$1 argument expects a value"
		else
			validateVersion $$1 "the version passed with the --set-version argument"
			SET_VERSION=$$1
		fi
		;;
	
	--auto|-a)
		AUTOMATED_MODE=1
		;;
		
	--amend)
		AMEND_ARGS="--amend --no-edit"
		;;
		
	--stash-dirty-files)
		STASH_DIRTY_FILES=1
		;;
		
	--commit-dirty-files)
		COMMIT_DIRTY_FILES=1
		;;
		
	--ignore-dirty-files)
		IGNORE_DIRTY_FILES=1
		NO_COMMIT=1
		NO_TAG=1
		;;
	
	--no-commit)
		NO_COMMIT=1
		NO_TAG=1
		;;
	
	--no-tag)
		NO_TAG=1
		;;
	
	--tag)
		TAG_WHEN_DONE=1
		;;
	
	--push)
		PUSH_WHEN_DONE=1
		;;
	
	--branch|-b)
		if [[ $$2 ]]; then
			BRANCH="$$2"
			shift
		fi
		;;
	
	--commit-message-file|-m)
		if [[ $$2 ]]; then
			COMMIT_MESSAGE=`cat "$$2"`
			shift
		fi
		;;

	--skip-docs)
		SKIP_DOCUMENTATION=1
		;;
		
	--skip-tests)
		SKIP_TESTS=1
		;;
		
	--quiet|-q)
		QUIET=1
		QUIET_ARG="-q"
		;;
		
	--rebase)
		REBASE=1
		;;
		
	--dry-run)
		DRY_RUN_MODE=1
		;;
	
	--help|-h|-\?)
		SHOW_HELP=1
		;;
		
	-*)
		exitWithErrorSuggestHelp "Unrecognized argument: $$1"
		;;
		
	*)
		if [[ -z $$ARGS ]]; then
			ARGS=$$1		
		else
			ARGS="$$ARGS $$1"
		fi
	esac
	shift
done

if [[ $$SHOW_HELP ]]; then
	showHelp
	exit 1
fi

for ARG in $$ARGS; do
	if [[ -z $$RELEASE_TYPE ]]; then
		RELEASE_TYPE="$$ARG"
	else 
		exitWithErrorSuggestHelp "Unrecognized argument: $$ARG"
	fi
done

#
# validate the input
#
if [[ $$(( $$STASH_DIRTY_FILES + $$COMMIT_DIRTY_FILES + $$IGNORE_DIRTY_FILES )) > 1 ]]; then
	exitWithErrorSuggestHelp "The --stash-dirty-files, --commit-dirty-files and --ignore-dirty-files arguments are mutually exclusive and can't be used with each other"
fi
if [[ ! -z $$RELEASE_TYPE ]]; then
	if [[ ! -z $$SET_VERSION ]]; then
		exitWithErrorSuggestHelp "The release type can't be specified when --set-version is used"
	elif [[ $$RELEASE_TYPE != "major" && $$RELEASE_TYPE != "minor" && $$RELEASE_TYPE != "patch" ]]; then
		exitWithErrorSuggestHelp "The release type argument must be one of: 'major', 'minor' or 'patch'"
	fi
elif [[ -z $$SET_VERSION ]]; then
	if [[ -z $$RELEASE_TYPE ]]; then
		exitWithErrorSuggestHelp "The release type ('major', 'minor' or 'patch') must be specified as an argument."
	fi
fi

#
# figure out what the current version is
#
FRAMEWORK_PLIST_FILE="Info-Target.plist"
FRAMEWORK_PLIST_PATH="$$SCRIPT_DIR/../$$FRAMEWORK_PLIST_FILE"
PLIST_BUDDY=/usr/libexec/PlistBuddy
CURRENT_VERSION=`$$PLIST_BUDDY "$$FRAMEWORK_PLIST_PATH" -c "Print :CFBundleShortVersionString"`
validateVersion "$$CURRENT_VERSION" "the CFBundleShortVersionString value in the $$FRAMEWORK_PLIST_FILE file"

#
# now, do the right thing depending on the command-line arguments
#
if [[ ! -z $$SET_VERSION ]]; then
	VERSION=$$SET_VERSION
elif [[ ! -z $$RELEASE_TYPE ]]; then
	MAJOR_VERSION=`echo $$CURRENT_VERSION | awk -F . '{print int($$1)}'`
	MINOR_VERSION=`echo $$CURRENT_VERSION | awk -F . '{print int($$2)}'`
	PATCH_VERSION=`echo $$CURRENT_VERSION | awk -F . '{print int($$3)}'`

	case $$RELEASE_TYPE in
	major)
		MAJOR_VERSION=$$(( $$MAJOR_VERSION + 1 ))
		MINOR_VERSION=0
		PATCH_VERSION=0
		;;
		
	minor)
		MINOR_VERSION=$$(( $$MINOR_VERSION + 1 ))
		PATCH_VERSION=0
		;;
		
	patch)
		PATCH_VERSION=$$(( $$PATCH_VERSION + 1 ))
		;;
	esac
	
	VERSION="$${MAJOR_VERSION}.$${MINOR_VERSION}.$${PATCH_VERSION}"
fi

#
# try to figure out the origin repo name
#
REPO_NAME=$$(git remote -v | grep "^origin" | grep "(fetch)" | awk '{print $$2}' | xargs basename | sed 'sq.git$$qq')
if [[ -z "$$REPO_NAME" ]]; then
	exitWithErrorSuggestHelp "Couldn't determine repo name"
fi

#
# output a warning if there are conflicting tag flags
#
if [[ $$TAG_WHEN_DONE && $$NO_TAG ]]; then
	exitWithErrorSuggestHelp "--tag can't be specified with --no-tag, --no-commit or --ignore-dirty-files"
fi

#
# see if we've got uncommitted changes
#
git diff-index --quiet HEAD -- ; REPO_IS_DIRTY=$$?
if [[ $$REPO_IS_DIRTY != 0 && $$(( $$STASH_DIRTY_FILES + $$COMMIT_DIRTY_FILES + $$IGNORE_DIRTY_FILES )) == 0 ]]; then
	exitWithErrorSuggestHelp "You have uncommitted changes in this repo; won't do anything" "(use --stash-dirty-files, --commit-dirty-files or^q(\n)^q(\t)--ignore-dirty-files to bypass this error)"
fi

confirmationPrompt "Releasing $$REPO_NAME $$VERSION (current is $$CURRENT_VERSION)"

if [[ $$REPO_IS_DIRTY && $$STASH_DIRTY_FILES > 0 ]]; then
	updateStatus "Stashing modified files"
	executeCommand "git stash"
    trap cleanupDirtyStash EXIT
fi

#
# make sure it builds
#
XCODEBUILD=/usr/bin/xcodebuild
XCODEBUILD_CMD="$$XCODEBUILD"
updateStatus "Verifying that $$REPO_NAME builds"
if [[ $$QUIET ]]; then
	XCODEBUILD_CMD="$$XCODEBUILD -quiet"
fi
if [[ ! -x "$$XCODEBUILD" ]]; then
	exitWithErrorSuggestHelp "Expected to find xcodebuild at path $$XCODEBUILD"
fi

#
# use xcpretty if it is available
#
XCODEBUILD_PIPETO=""
XCPRETTY=`which xcpretty`
if [[ $$? == 0 ]]; then
	XCODEBUILD_PIPETO="| $$XCPRETTY"
fi

#
# determine build settings
#
PROJECT_SPECIFIER="^if($project:hasWorkspace|-workspace $project:workspace|-project $project:file)"
COMPILE_PLATFORMS="^join($project:platforms| )"
PROJECT_NAME="${project:name}"

testActionForPlatform()
{
	case $$1 in
	iOS) 		echo "^if(!$project:skipUnitTests -AND $platforms:build[iOS][supportsUnitTests]|test|build)";;
	macOS) 		echo "^if(!$project:skipUnitTests -AND $platforms:build[macOS][supportsUnitTests]|test|build)";;	
	tvOS) 		echo "^if(!$project:skipUnitTests -AND $platforms:build[tvOS][supportsUnitTests]|test|build)";;
	watchOS)	echo "^if(!$project:skipUnitTests -AND $platforms:build[watchOS][supportsUnitTests]|test|build)";;
	esac
}

runDestinationForPlatform()
{
	case $$1 in
	iOS) 		echo "$platforms:build[iOS][runDestination]";;
	macOS) 		echo "$platforms:build[macOS][runDestination]";;	
	tvOS) 		echo "$platforms:build[tvOS][runDestination]";;
	watchOS)	echo "$platforms:build[watchOS][runDestination]";;
	esac
}

#
# build for each platform
#
for PLATFORM in $$COMPILE_PLATFORMS; do
	updateStatus "Building: $$PROJECT_NAME for $$PLATFORM..."
	if [[ $$SKIP_TESTS ]]; then
		BUILD_ACTION="clean build"
	else
		BUILD_ACTION="clean $$(testActionForPlatform $$PLATFORM)"
	fi
	RUN_DESTINATION="$$(runDestinationForPlatform $$PLATFORM)"
	executeCommand "$$XCODEBUILD_CMD $$PROJECT_SPECIFIER -scheme \"$${REPO_NAME}^if($project:usesPlatformSpecificSchemes|-^q($){PLATFORM})\" -configuration Debug -destination \"$$RUN_DESTINATION\" $$BUILD_ACTION $$XCODEBUILD_PIPETO"
done

#
# bump version numbers
#
updateStatus "Adjusting version numbers"
executeCommand "$$PLIST_BUDDY \"$$FRAMEWORK_PLIST_PATH\" -c \"Set :CFBundleShortVersionString $$VERSION\""
agvtool bump > /dev/null

if [[ ! $$SKIP_DOCUMENTATION ]]; then
	updateStatus "Rebuilding documentation"
	"$$SCRIPT_DIR/generateDocumentationForAPI.sh" $$QUIET_ARG
	executeCommand "git add Documentation/."
fi

#
# commit changes
#
BUILD_NUMBER=`agvtool vers -terse`
if [[ -z $$COMMIT_MESSAGE ]]; then
	COMMIT_MESSAGE="Release $$VERSION (build $$BUILD_NUMBER)"
	if [[ $$REPO_IS_DIRTY && $$COMMIT_DIRTY_FILES > 0 ]]; then
		COMMIT_MESSAGE="$$COMMIT_MESSAGE -- committed with other changes"
	fi
fi
if [[ -z $$NO_COMMIT ]]; then
	updateStatus "Committing changes"
	printf "%s" "$$COMMIT_MESSAGE" | git commit -a $$QUIET_ARG $$AMEND_ARGS -F -
else
	updateStatus "! Not committing changes; --no-commit or --ignore-dirty-files was specified"
	printf "> To commit manually, use:^q(\n\n)    git commit -a -m '$$COMMIT_MESSAGE'^q(\n)"
fi

#
# rebase with existing changes if needed
#
if [[ $$REBASE ]]; then
	updateStatus "Rebasing with existing $$BRANCH branch"
	executeCommand "git pull origin $$BRANCH $$QUIET_ARG --rebase --allow-unrelated-histories --strategy=recursive -Xtheirs"
fi

#
# tag repo with new version number
#
if [[ $$TAG_WHEN_DONE && -z $$NO_COMMIT && -z $$NO_TAG ]]; then
	updateStatus "Tagging repo for $$VERSION release"
	executeCommand "git tag -a $$VERSION -m 'Release $$VERSION issued by $$SCRIPT_NAME'"
else
	updateStatus "! Not tagging repo; --tag was not specified"
	printf "> To tag manually, use:^q(\n\n)    git tag -a $$VERSION -m 'Release $$VERSION issued by $$SCRIPT_NAME'^q(\n)"
fi

#
# push if we should
#
if [[ $$PUSH_WHEN_DONE && -z $$NO_COMMIT ]]; then
	updateStatus "Pushing changes to origin"
	executeCommand "git push $$QUIET_ARG"
	if [[ $$TAG_WHEN_DONE && !$$NO_TAG ]]; then
		executeCommand "git push --tags $$QUIET_ARG"
	fi
else
	printf "^q(\n)> REMEMBER: The release isn't done until you push the changes! Don't forget to:^q(\n\n)    git push && git push --tags^q(\n)"
fi
